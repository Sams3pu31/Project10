1) Что такое поток? Что такое процесс? В чем их различие?

Поток - это наименьшая единица выполнения внутри процесса. Он представляет собой последовательность инструкций, 
   которая может выполняться параллельно с другими потоками внутри одного процесса.

Процесс - это экземпляр программы, которая запущена на компьютере. Процесс включает в себя память, ресурсы, код программы и один или несколько потоков.

Отличие между ними заключается в том, что процесс может содержать несколько потоков, каждый из которых выполняет разные задачи, но все они работают в рамках одного процесса. Потоки внутри одного процесса могут совместно использовать ресурсы и данные, что делает их более эффективными в обмене информацией, чем отдельные процессы.

2) Может ли поток существовать без процесса?

Обычно потоки существуют в рамках процессов. Один процесс может содержать один или несколько потоков. Однако, 
существуют так называемые "демоны" в Java, которые могут существовать, пока выполняется основной процесс Java. Такие 
потоки могут существовать даже после завершения основного процесса, но они зависят от существующего процесса.

3) Какие способы создания потока в Java вы знаете?

Реализация интерфейса Runnable.
Наследование от класса Thread.
Использование Executor Framework из пакета java.util.concurrent.
Использование Callable и Future из пакета java.util.concurrent.

4) Какой способ создания потока лучше и почему?

Обычно рекомендуется предпочитать реализацию интерфейса Runnable, так как это способствует лучшей структуре кода, избегает ограничений на наследование, и позволяет легче достичь согласованности интерфейсов и логики при проектировании приложения.

5) Какие состояния потока вы знаете?

NEW: Поток был создан, но еще не запущен.
RUNNABLE: Поток выполняется или готов к выполнению.
BLOCKED: Поток заблокирован, ожидая монитор или блокировку.
WAITING: Поток ожидает определенного условия для продолжения.
TIMED_WAITING: Поток ожидает определенный период времени перед возобновлением работы.
TERMINATED: Поток завершил свою работу и прекратил выполнение.

6) Как внутри программы узнать текущее состояние потока?

Вы можете получить текущее состояние потока с помощью метода Thread.getState(), который возвращает объект Thread.State, представляющий состояние потока.

7) Что такое приоритет потока? Какой приоритет стоит по умолчанию?

Приоритет потока определяет его относительную важность и влияет на то, как процессор распределяет время выполнения между потоками. Приоритеты находятся в диапазоне от MIN_PRIORITY (1) до MAX_PRIORITY (10), а по умолчанию установлен приоритет NORM_PRIORITY (5).

8) Что такое группа потоков? Для чего она нужна?

Группа потоков (Thread Group) - это механизм для организации и управления коллекцией потоков. Она позволяет логически группировать потоки для управления ими единообразно, например, для обработки исключений, приостановки или прерывания всех потоков в группе.

9) Как перевести поток из состояния NEW в RUNNABLE?

После создания потока вызовите метод start(), который начнет выполнение потока и переведет его из состояния NEW в RUNNABLE:


10) Как поток может оказаться в состоянии BLOCKED?

Поток может быть в состоянии BLOCKED, когда он ожидает блокировки для доступа к ресурсу, который занят другим потоком. Например, если один поток захватил монитор объекта, другие потоки, пытающиеся получить доступ к этому объекту, могут быть заблокированы до освобождения монитора.

11) Для чего нужны методы join() и join(t)? Меняется ли состояние потока при их применении?

Метод join() используется для ожидания завершения потока, на котором он вызван. Метод join(t) ожидает завершения потока не более чем t миллисекунд. Вызов метода join() или join(t) блокирует текущий поток до завершения указанного потока. Состояние потока, вызвавшего join(), становится WAITING или TIMED_WAITING до завершения другого потока.

12) Для чего нужны методы wait() и wait(t)? Меняется ли состояние потока при их применении?

Методы wait() и wait(t) используются для временного приостановления потока и освобождения блокировки объекта. Вызов этих методов заставляет текущий поток ждать, пока другой поток не вызовет метод notify() или notifyAll() для того же самого объекта. При вызове wait() или wait(t) состояние потока становится WAITING или TIMED_WAITING.

13) Для чего нужны методы notify() и notifyAll()? В чем их различие? Меняется ли состояние потока при их применении?

Метод notify() используется для возобновления одного случайного потока, ожидающего на том же самом объекте, для которого был вызван метод wait(). Метод notifyAll() возобновляет все потоки, ожидающие на этом объекте. Вызов notify() или notifyAll() не изменяет состояние потока напрямую, он только уведомляет ожидающие потоки.

14) В каких единицах указывается значение времени в методах: join(t), wait(t), sleep(t)?

15) Для чего используется метод interrupt()?

Метод interrupt() используется для прерывания выполнения потока. Он устанавливает флаг прерывания потока, что может привести к выбросу исключения InterruptedException, если поток находится в блокированном или ожидающем состоянии (например, sleep(), wait()). Метод interrupt() не останавливает поток принудительно, он только устанавливает флаг прерывания, который поток может проверить и решить, как реагировать на это прерывание.






